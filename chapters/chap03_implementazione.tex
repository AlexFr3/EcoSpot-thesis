\chapter{Sviluppo e Implementazione}
\label{chap:implementation}

Questo capitolo descrive le scelte progettuali e le soluzioni tecniche adottate per la realizzazione del sistema \textit{EcoSpot}. 
La trattazione si focalizza sull'organizzazione interna dell'applicazione mobile, descrivendo la suddivisione in layer logici, la gestione dello stato tramite Riverpod e le soluzioni tecniche adottate per le funzionalità chiave come la mappa interattiva, la gamification e l'integrazione dei sensori IoT.

\section{Architettura dell'App}
Il progetto è stato strutturato seguendo una divisione in layer logici per garantire manutenibilità (Requisito \ref{rnf:manutenibilita}), scalabilità e 
testabilità del codice. La cartella sorgente è organizzata nei seguenti moduli principali:

\begin{itemize}
    \item \textbf{Data Layer}: Contiene le definizioni delle entità fondamentali del dominio. Qui risiedono le classi \texttt{UserModel} per la gestione del profilo utente, \texttt{Species} per la catalogazione di flora e fauna e \texttt{SensorData} per la gestione delle rilevazioni ambientali. Include inoltre i file di configurazione statica come \texttt{SensorConfig} e \texttt{Env}.
    
    \item \textbf{Service Layer}: Gestisce la comunicazione con le sorgenti dati esterne. In questo modulo sono stati implementati:
    \begin{itemize}
        \item \texttt{AuthService}: Per l'astrazione delle logiche di autenticazione Firebase (Google Sign-In, Email/Password e Accesso Anonimo).
        \item \texttt{DatabaseHelper}: Per le operazioni \ac{CRUD} sul database NoSQL Cloud Firestore e lo storage dei file multimediali.
        \item \texttt{SensorService}: Per il recupero dei dati IoT tramite chiamate REST API verso l'endpoint dedicato.
        \item \texttt{WeatherService}: Per l'integrazione con le \ac{API} di Open-Meteo.
    \end{itemize}
    
    \item \textbf{State Management Layer}: Utilizza il pacchetto \textbf{Riverpod} per la gestione dello stato reattivo e la \textit{Dependency Injection} \cite{riverpod}. 
    Il file \texttt{app\_providers.dart} centralizza i provider globali, gestendo flussi asincroni come lo stato dell'autenticazione e il caricamento dei 
    dati geo-spaziali.
    
    \item \textbf{Presentation Layer}: Comprende i widget dell'interfaccia utente, separando le pagine principali (es. \texttt{HomePage}, 
    \texttt{StatisticsPage}) dai componenti riutilizzabili (es. \texttt{MapWidget}) e dalla definizione del tema visivo.
\end{itemize}

\section{Sviluppo dell'App}
Lo sviluppo si è concentrato sulla creazione di un'esperienza utente fluida, sfruttando le capacità multi-piattaforma di Flutter e un'architettura reattiva solida. Di seguito vengono analizzati i componenti tecnici fondamentali: la gestione dello stato, la visualizzazione cartografica, le meccaniche di gamification e l'integrazione IoT.

\subsection{Gestione dello Stato}
La gestione globale dello stato è affidata al file \texttt{app\_providers.dart}, che definisce i provider \textbf{Riverpod} per l'intera applicazione. Questo approccio centralizzato permette di implementare una \textit{Dependency Injection} robusta: i servizi core come \texttt{DatabaseHelper} o \texttt{AuthService} vengono istanziati una sola volta e iniettati nei widget o in altri provider tramite il riferimento \texttt{ref}, migliorando la testabilità e la modularità del codice.

Un aspetto cruciale dell'architettura è la capacità di creare "stati derivati". Un esempio significativo è rappresentato dal \texttt{speciesProvider}. Invece di esporre semplicemente la lista statica della fauna, questo provider combina in modo asincrono i dati grezzi delle specie con il profilo dell'utente corrente (recuperato tramite \texttt{userProfileProvider}). In questo modo, il flag \texttt{isVisited} di ogni entità viene calcolato dinamicamente prima ancora di raggiungere l'interfaccia utente.

\begin{listing}[H]
\begin{minted}[frame=single, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, breaklines]{dart}
// File: lib/providers/app_providers.dart

final speciesProvider = FutureProvider<List<Species>>((ref) async {
  // 1. Recupero asincrono della lista completa delle specie
  final allSpecies = await ref.watch(_rawSpeciesProvider.future);

  // 2. Ascolto reattivo del profilo utente
  final userProfile = ref.watch(userProfileProvider).asData?.value;
  final visitedIds = userProfile?.visitedSpeciesIds ?? [];

  // 3. Incrocio dei dati per determinare lo stato di visita
  for (var species in allSpecies) {
    species.isVisited = visitedIds.contains(species.id);
  }

  return allSpecies;
});
\end{minted}
\caption{Logica di stato derivato per la gestione delle specie visitate}
\label{lst:species_provider}
\end{listing}

Grazie a questa struttura, l'interfaccia utente (implementata tramite \texttt{ConsumerWidget}) reagisce istantaneamente ai cambiamenti: se l'utente effettua una nuova scoperta, il \texttt{userProfileProvider} emette un nuovo stato, il \texttt{speciesProvider} ricalcola la lista e la mappa si aggiorna automaticamente mostrando il nuovo badge di avvenuta visita, senza necessità di callback manuali o controller complessi.

\subsubsection{Sincronizzazione Dati}
L'implementazione della logica reattiva si basa sull'utilizzo degli \texttt{StreamProvider} di Riverpod, un pattern che permette di gestire flussi di dati asincroni garantendo che l'interfaccia si aggiorni automaticamente al variare dello stato sottostante.

Nel caso del tracciamento utente, il provider \texttt{userPositionProvider} (definito in \texttt{app\_providers.dart}) 
funge da ponte tra l'hardware del dispositivo e il livello logico dell'applicazione. Esso sottoscrive lo stream di eventi 
del plugin \textit{Geolocator}, gestendo preliminarmente i permessi di localizzazione e emettendo oggetti \texttt{LatLng} 
solo quando disponibili(Requisito \ref{req:tracking}).

Di seguito è riportata l'implementazione del provider, che incapsula la complessità della gestione dei permessi e la generazione dello stream:

\begin{listing}[H]
\begin{minted}[frame=single, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, breaklines]{dart}
  // File: lib/providers/app_providers.dart

final userPositionProvider = StreamProvider<LatLng?>((ref) async* {
  bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
  if (!serviceEnabled) {
    yield null;
    return;
  }

  LocationPermission permission = await Geolocator.checkPermission();
  if (permission == LocationPermission.denied) {
    permission = await Geolocator.requestPermission();
    if (permission == LocationPermission.denied) {
      yield null;
      return;
    }
  }

  // Generazione continua delle coordinate
  await for (final position in Geolocator.getPositionStream()) {
    yield LatLng(position.latitude, position.longitude);
  }
});
\end{minted}
\end{listing}

Il widget \texttt{MapWidget} consuma questo stato non solo per aggiornare la visualizzazione, ma anche per innescare logiche di business critiche. 
Ogni aggiornamento di posizione invoca il metodo \texttt{\_checkDiscoveries}, che confronta la posizione attuale dell'utente con le coordinate dell'habitat 
delle specie non ancora visitate, utilizzando la classe \texttt{Distance} di \textit{latlong2} (Requisito \ref{req:geofencing}).
\begin{listing}[H]
  \begin{minted}[frame=single, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, breaklines]{dart}
  // File: lib/widgets/map_widget.dart

  void _checkDiscoveries(LatLng userLocation) {
    final user = ref.read(currentUserProvider);
    if (user == null) return;

    final allSpecies = ref.read(speciesProvider).valueOrNull ?? [];

    for (var species in allSpecies) {
      if (species.isVisited) continue;

      // Calcolo della distanza geodetica
      final double meters = _distanceCalculator.as(
          LengthUnit.Meter, userLocation, species.centerPoint);

      // Trigger della scoperta se nel raggio (discoveryRadius)
      if (meters <= species.discoveryRadius) {
        _triggerDiscovery(user.uid, species);
      }
    }
  }
  \end{minted}
\end{listing}

Questo approccio disaccoppia la ricezione del dato dalla logica applicativa, ottimizzando le risorse del dispositivo mobile.
\subsection{Interfaccia Utente}
L'interfaccia grafica è stata progettata rispettando le linee guida del \textbf{Material Design 3}, al fine di garantire coerenza visiva 
e usabilità multipiattaforma (Requisito \ref{req:multipiattaforma}). La gestione dei temi è centralizzata nella classe \texttt{AppColors}, che definisce le 
palette cromatiche per la modalità chiara e scura (gestite tramite il provider \texttt{themeModeProvider}). Il sistema 
adatta automaticamente sfondi, testi e gradienti in base alle preferenze del sistema operativo o alle scelte dell'utente (Requisito \ref{rnf:usabilita}).

\begin{figure}[H]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/app_img/home.png}
        \caption{Home con tema scuro}
        \label{fig:dark_theme}
    \end{minipage}
    \hfill 
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/app_img/lightTheme.png}
        \caption{Home con tema chiaro}
        \label{fig:light_theme}
    \end{minipage}
\end{figure}

L'accesso all'applicazione è mediato da una schermata di login (Figura \ref{fig:login_page}) che offre tre modalità di autenticazione, orchestrate dall'\texttt{AuthService}: credenziali standard (email/password), Google Sign-In per un accesso rapido e una modalità \enquote{Ospite} anonima, pensata per consentire l'esplorazione delle funzionalità base prima della registrazione.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{figures/app_img/login.png}
    \caption{Schermata di Login con opzioni di accesso multiplo.}
    \label{fig:login_page}
\end{figure}

L'architettura della navigazione e delle viste principali si articola come segue:

\begin{itemize}
    \item \textbf{Home Dashboard:} La schermata principale utilizza un widget \texttt{Stack} per sovrapporre elementi UI fluttuanti al layer cartografico. Nella parte superiore, una barra di ricerca con 
    autocompletamento facilita il filtraggio delle specie (Requisito \ref{req:ricerca}), mentre widget dedicati mostrano il meteo locale in tempo reale (tramite \texttt{WeatherService}). I pulsanti d'azione consentono di ricentrare la visuale sulla posizione dell'utente, gestire i layer della mappa o aprire il dialog delle segnalazioni.
    
    \item \textbf{Schede di Dettaglio:} Per la consultazione di fauna e flora sono stati implementati widget basati su \texttt{DraggableScrollableSheet}. Questo componente permette all'utente di trascinare la scheda dal basso verso l'alto (coprendo dal 50\% al 95\% dello schermo) rivelando descrizioni, curiosità e dati scientifici. L'esperienza utente è arricchita da animazioni \texttt{Hero}, che collegano fluidamente l'icona del marker sulla mappa all'immagine di copertina della scheda.

    \item \textbf{Profilo e Statistiche:} Questa sezione impiega una \texttt{CustomScrollView} con \texttt{SliverAppBar} per creare un header collassabile contenente il rango e il livello utente. Il corpo della pagina ospita una \texttt{GridView} che visualizza la collezione delle specie: gli elementi scoperti appaiono a colori (con un bordo indicante la rarità), mentre quelli non ancora visitati sono mostrati in scala di grigi, sfruttando la gamification per incentivare il completamento della raccolta.
\end{itemize}
\subsection{Mappa Interattiva e Clustering}
La visualizzazione cartografica è il punto centrale dell'interazione ed è gestita dal widget \texttt{MapWidget}, che integra la libreria \textit{flutter\_map} 
per il rendering di mappe basate su tiles OpenStreetMap (Requisito \ref{req:mappa}).

L'architettura della mappa è basata su uno \texttt{Stack} di layer sovrapposti, che permette di separare il livello di base (le tiles geografiche) dai 
livelli informativi (marker e UI). Per garantire prestazioni elevate anche con un numero crescente di elementi sulla mappa, è stata adottata una strategia 
ibrida di rendering.

Per quanto riguarda la \textbf{Gestione Layer e Filtri}, l'utente ha la possibilità di attivare o disattivare dinamicamente diverse 
categorie di marker (Fauna, Aree Verdi, Sensori, Punti di Interesse) tramite un dialog di configurazione (Requisito \ref{req:ricerca}). 
Questa logica è gestita tramite variabili di stato booleane (es. \texttt{\_showAnimals}, \texttt{\_showSensors}) che condizionano il rendering dei rispettivi \texttt{MarkerLayer} all'interno del metodo \texttt{build}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.38\textwidth]{figures/app_img/layers.png}
  \caption{Pannello per la gestione dei livelli e filtri della mappa.}
  \label{fig:layers}
\end{figure}

Inoltre, è stato implementato il \textbf{Clustering dei Punti di Interesse (POI)}. Per evitare il sovraffollamento visivo (cluttering) quando si visualizzano i numerosi Punti di 
Interesse (configurati in \texttt{PoiConfig.points}) e per non compromettere le prestazioni di rendering, è stato integrato un sistema tramite il pacchetto \textit{flutter\_map\_marker\_cluster}. Questa libreria raggruppa automaticamente i marker vicini in un unico indicatore 
circolare contenente il numero di elementi nel cluster quando lo zoom della mappa è basso, che si espande (de-cluster) automaticamente 
aumentando il livello di zoom.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.40\textwidth]{figures/app_img/POI.png}
  \caption{Mappa posizionata su un cluster di POI e uno visibile}
  \label{fig:POI}
\end{figure}

Di seguito è riportata la configurazione del layer di clustering, che definisce il raggio di aggregazione e il builder personalizzato per l'indicatore numerico:

\begin{listing}[H]
  \begin{minted}[frame=single, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, breaklines]{dart}
    // File: lib/widgets/map_widget.dart

  MarkerClusterLayerWidget(
    options: MarkerClusterLayerOptions(
      maxClusterRadius: 60, // Raggio di aggregazione in pixel
      disableClusteringAtZoom: 16, // Disabilita clustering a zoom elevati
      size: const Size(40, 40),
      markers: poiMarkers, // Lista dei marker POI
      builder: (context, markers) {
        return Container(
          decoration: BoxDecoration(
            color: AppColors.primary,
            shape: BoxShape.circle,
            border: Border.all(color: Colors.white, width: 2),
          ),
          child: Center(
            child: Text(
              markers.length.toString(),
              style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
            ),
          ),
        );
      },
    ),
  )
  \end{minted}
\end{listing}


Al contrario dei POI, gli elementi faunistici sono renderizzati singolarmente per evidenziare attributi specifici immediati: ogni marker animale è circondato 
da un bordo colorato che ne indica la rarità (es. oro per "Leggendario", grigio per "Comune"), permettendo all'utente di identificare a colpo d'occhio le 
specie di maggior valore. L'interazione con i marker apre schede di dettaglio modali (si veda Figura \ref{fig:species_detail_sheet} \texttt{SpeciesDetailSheet}) o finestre di dialogo per i sensori, 
fornendo un'esperienza utente fluida e informativa.

La Figura \ref{fig:home_map} mostra la schermata principale dell'applicazione, dove l'utente può visualizzare la propria posizione in tempo reale e i punti di interesse circostanti.

\begin{figure}[H]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/app_img/home.png}
        \caption{Schermata principale con mappa interattiva.}
        \label{fig:home_map}
    \end{minipage}
    \hfill 
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/app_img/species_details.png}
        \caption{Dettaglio specie con scheda informativa.}
        \label{fig:species_detail_sheet}
    \end{minipage}
\end{figure}

Inoltre, l'utente ha la possibilità di gestire la stratificazione dei contenuti visualizzati sulla mappa tramite un apposito pannello di controllo 
(Figura \ref{fig:layers}). L'implementazione tecnica di questa funzionalità risiede nel metodo \texttt{\_openFilterDialog}, che istanzia un'interfaccia modale contenente una serie di interruttori (\texttt{SwitchListTile}).

Oltre alla visualizzazione, i marker sono interattivi. Come mostrato nel Codice \ref{lst:map_markers}, l'utilizzo di \texttt{GestureDetector} permette di aprire schede di dettaglio modali (\texttt{showModalBottomSheet}) al tocco dell'utente.

Per le \textbf{Aree Verdi} come per le specie di animali, è stata implementata una logica che associa a ogni entità geografica un widget \texttt{Marker} 
personalizzato.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{figures/app_img/green_area_details.png}
    \caption{Dettaglio area verde con scheda informativa}
    \label{fig:green_area_details}
\end{figure} 

Come illustrato nel seguente Codice \ref{lst:map_markers}, ogni marker viene incapsulato in un \texttt{GestureDetector}: questo permette di 
intercettare l'evento \texttt{onTap} dell'utente e scatenare l'apertura della scheda di dettaglio (\texttt{GreenAreaDetailSheet}) tramite una modale dal basso,
garantendo un'esperienza di navigazione fluida e intuitiva.


\begin{listing}[H]
  \begin{minted}[frame=single, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, breaklines]{dart}
  // Rendering dei marker delle aree verdi (estratto da MapWidget)
  ...widget.greenAreas.map((area) {
    return Marker(
      point: area.centerPoint,
      width: 70,
      height: 70,
      alignment: Alignment.topCenter,
      child: GestureDetector(
        onTap: () {
          showModalBottomSheet(
            context: context,
            isScrollControlled: true,
            backgroundColor: Colors.transparent,
            builder: (context) => GreenAreaDetailSheet(species: area),
          );
        },
        child: Image.asset(area.imagePath),
      ),
    );
  })
  \end{minted}
  \caption{Rendering dei marker interattivi sulla mappa}
  \label{lst:map_markers}
\end{listing}

\subsection{Gamification}
Il cuore dell'esperienza utente è il sistema di scoperta ("Discovery"), progettato per incentivare l'esplorazione fisica del Parco. L'applicazione calcola costantemente la distanza geodetica tra la posizione dell'utente e quella delle specie target, sfruttando la precisione offerta dal pacchetto \texttt{latlong2}.

\subsubsection{Logica di Scoperta}
Il meccanismo di controllo agisce in background ogni qualvolta il GPS rileva un aggiornamento della posizione. L'algoritmo (Codice \ref{lst:discovery}) scansiona le entità non ancora visitate, verificando se la distanza attuale rientri nel raggio di scoperta (\texttt{discoveryRadius}), parametro che si adatta dinamicamente alla tipologia di specie (es. 450m per la fauna, 800m per le aree verdi).

Al soddisfacimento della condizione, il sistema innesca una doppia procedura: a livello di backend esegue una transazione atomica su Firestore per registrare l'ID della specie e i relativi punti esperienza, 
tutelando la consistenza del dato (Requisito \ref{req:integrita}) anche in caso di instabilità della rete (Requisito \ref{req:offline}); contestualmente, sul frontend, gratifica l'utente 
con un feedback visivo immediato tramite \texttt{SnackBar} e l'apertura automatica della scheda descrittiva 
(\texttt{SpeciesDetailSheet}).

\begin{listing}[H]
\begin{minted}[frame=single, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, breaklines]{dart}
void _checkDiscoveries(LatLng userLocation) {
  final user = ref.read(currentUserProvider);
  if (user == null) return;

  final allSpecies = ref.read(speciesProvider).valueOrNull ?? [];

  for (var species in allSpecies) {
    if (species.isVisited) continue;

    // Calcolo distanza geodetica in metri
    final double meters = _distanceCalculator.as(
        LengthUnit.Meter, userLocation, species.centerPoint);

    // Verifica soglia di scoperta specifica per la specie
    if (meters <= species.discoveryRadius) {
      _triggerDiscovery(user.uid, species);
    }
  }
}
\end{minted}
\caption{Algoritmo di scoperta basato sulla distanza geodetica}
\label{lst:discovery}
\end{listing}
\subsubsection{Utente e Rango}
Il modello utente (\texttt{UserModel}) incapsula la logica di progressione tramite l'estensione \texttt{UserStatsLogic}. Il livello viene calcolato dinamicamente dividendo gli 
XP totali per la soglia fissa (Requisito \ref{req:gamification}) di 1000 punti (\texttt{xpPerLevel}).

In base al livello raggiunto, il sistema assegna un rango onorifico che evolve progressivamente: "Esploratore" ($<$ Lv. 5), "Naturalista" ($<$ Lv. 10), "Guardiano" ($<$ Lv. 20) fino a "Leggenda del Delta". Questo aggiornamento avviene in tempo reale grazie agli stream di Firestore, sbloccando nuovi badge visibili nella sezione statistiche (Figura \ref{fig:stats_page}).

\begin{listing}[H]
\begin{minted}[frame=single, framesep=2mm, baselinestretch=1.0, fontsize=\footnotesize, breaklines]{dart}
extension UserStatsLogic on UserModel {
  // Calcolo Rank basato sul livello
  String get rank {
    if (level < 5) return 'Esploratore';
    if (level < 10) return 'Naturalista';
    if (level < 20) return 'Guardiano';
    return 'Leggenda del Delta';
  }
  
  int get speciesDiscovered => visitedSpeciesIds.length;
  
  // XP necessari per completare il livello precedente
  int get xpForNextLevel => level * UserModel.xpPerLevel;
  
  // Calcolo degli XP parziali nel livello corrente
  int get currentLevelXP {
    final xpOfPreviousLevels = (level - 1) * UserModel.xpPerLevel;
    return totalXp - xpOfPreviousLevels;
  }

  double get progressToNextLevel {
    if (xpForNextLevel == 0) return 0;
    return (currentLevelXP / UserModel.xpPerLevel).clamp(0.0, 1.0);
  }
}
\end{minted}
\caption{Logica di estensione per il calcolo del rango e del livello}
\label{lst:statsLogic}
\end{listing}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.40\textwidth]{figures/app_img/statistics.png}
    \caption{Pagina delle statistiche con progresso livello e riepilogo collezione.}
    \label{fig:stats_page}
\end{figure}

\subsubsection{Segnalazioni}
Gli utenti contribuiscono attivamente al monitoraggio ambientale tramite la funzione di segnalazione (Requisito \ref{req:segnalazioni}). 
Il widget \texttt{ReportDialog} (Figura \ref{fig:report_dialog}) orchestra l'acquisizione dati integrando il 
pacchetto \texttt{image\_picker} per la fotografia e \texttt{geolocator} per associare le coordinate 
GPS esatte al momento dello scatto.

I dati raccolti vengono incapsulati in un oggetto \texttt{ReportModel} e inviati al backend. Il completamento di questa operazione innesca una transazione che premia l'utente con 50 XP immediati, incentivando la partecipazione civica alla salvaguardia del territorio.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{figures/app_img/reports.png}
    \caption{Interfaccia per l'invio di una segnalazione geolocalizzata.}
    \label{fig:report_dialog}
\end{figure}
\clearpage

\subsection{Integrazione Sensori}
Per fornire un quadro dettagliato dello stato ambientale del Parco, l'applicazione integra dati provenienti da stazioni di monitoraggio reali. 
L'architettura prevede una configurazione statica delle stazioni, definita nel codice per mappare le posizioni geografiche e gli identificativi hardware dei 
sensori collegati (Listing \ref{lst:sensor_config}).

\begin{listing}[H]
\begin{minted}[frame=single, framesep=2mm, baselinestretch=1.3, fontsize=\footnotesize, breaklines]{dart}
// Configurazione della stazione "Sifone Casalino"
SensorData(
  id: 'station_casalino',
  name: 'Sifone Casalino',
  type: 'station',
  location: const LatLng(44.551963, 12.138596),
  // Mappatura ID sensore remoto -> Nome visualizzato
  linkedSensors: {
    '26355': 'Profondità Hydros-21 (mm)',
    '26356': 'Temperatura Hydros-21 (°C)',
    '26357': 'Conducibilità Hydros-21 (mS/cm)',
  },
),
\end{minted}
\caption{Modellazione di una stazione di monitoraggio e dei suoi sensori}
\label{lst:sensor_config}
\end{listing}

Sfruttando questi identificativi univoci, il servizio \texttt{SensorService} interroga ciclicamente l'API esterna (Requisito \ref{req:iot}). 
Poiché le risposte del server possono variare nel formato a seconda del tipo di sensore, è stato implementato un sistema 
di parsing robusto che normalizza i dati in entrata 
prima di renderli disponibili alla UI (Listing \ref{lst:sensor_parsing}).

\begin{listing}[H]
\begin{minted}[frame=single, framesep=2mm, baselinestretch=1.2, fontsize=\footnotesize, breaklines]{dart}
// Parsing della risposta HTTP nel SensorService
final response = await http.post(Uri.parse(_apiUrl), ...);

if (response.statusCode == 200) {
  final decodedBody = jsonDecode(response.body);
  
  // Normalizzazione valore sensore (gestione formati misti)
  dynamic value;
  if (decodedBody is Map) {
    // Estrazione prioritaria del campo 'sensorValue' o fallback su 'value'
    value = decodedBody['sensorValue'] ?? decodedBody['value'];
  } else {
    value = decodedBody; // Caso in cui l'API restituisce un raw value diretto
  }
  
  return MapEntry(sensorName, value ?? "N/D");
}
\end{minted}
\caption{Logica di estrazione e normalizzazione dei dati JSON}
\label{lst:sensor_parsing}
\end{listing}

L'unione di questi due componenti permette di visualizzare popup informativi interattivi sulla mappa: cliccando sull'icona di una stazione, l'utente visualizza i parametri ambientali aggiornati in tempo reale, come temperatura dell'acqua, livello idrometrico e conduttività.

